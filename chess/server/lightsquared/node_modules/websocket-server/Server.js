define(function(require) {
	var time = require("js/time");
	var Event = require("js/Event");
	var http = require("http");
	var WsServer = require("websocket").server;
	var Client = require("./_Client");
	var User = require("./_User");
	var crypto = require("crypto");
	
	var CLEANUP_USERS_INTERVAL = 1000 * 60 * 30;

	function Server(port) {
		port = port || 8080;
		
		this.UserConnected = new Event();
		
		this._users = {};
		this._listen(port);
		
		setInterval((function() {
			this._cleanupUsers();
		}).bind(this), CLEANUP_USERS_INTERVAL);
	}

	Server.prototype._listen = function(port) {
		var httpServer = http.createServer(function(request, response) {
			response.writeHead(404);
			response.end();
		});

		httpServer.listen(port);

		var wsServer = new WsServer({
			httpServer: httpServer,
			keepalive: false
		});

		wsServer.on("request", (function(request) {
			var cookies = request.cookies.reduce(function(cookies, cookie) {
				cookies[cookie.name] = cookie.value;
				
				return cookies;
			}, {});
			
			var sessionId;
			var sendCookies = [];
	
			if("sessionId" in cookies) {
				sessionId = cookies["sessionId"];
			}
			
			else {
				do {
					sessionId = crypto.randomBytes(32).toString("base64");
				} while(sessionId in this._users);
				
				sendCookies.push({
					name: "sessionId",
					value: sessionId
				});
			}
			
			var connection = request.accept(null, request.origin, sendCookies);
			var client = new Client(connection);
		
			if(sessionId in this._users) {
				this._users[sessionId].addClient(client);
			}
			
			else {
				this._users[sessionId] = new User(client);
				this.UserConnected.fire(this._users[sessionId]);
			}
		}).bind(this));
	}
	
	Server.prototype._cleanupUsers = function() {
		var user;
		
		for(var sessionId in this._users) {
			user = this._users[sessionId];
			
			if(user.deregister()) {
				delete this._users[sessionId];
			}
		}
	}

	return Server;
});