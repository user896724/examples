define(function(require) {
	var Event = require("js/Event");
	var time = require("js/time");
	var Publisher = require("js/Publisher");
	
	function Client(connection) {
		this._connection = connection;
		this._publisher = new Publisher(this);
		
		this.Disconnected = new Event();
		
		this._timeLastMessageSent = 0;
		this._timeConnected = time();
		this._timeLastMessageReceived = 0;
		this._heartbeatInterval = 1000;
		this._maxTimeBetweenMessages = 3000;
		
		this._heartbeatLoop = setInterval((function() {
			this._checkHeartbeat();
			this._sendHeartbeatMessage();
		}).bind(this), this._heartbeatInterval);
		
		this._setupConnection();
	}
	
	Client.prototype.subscribe = function(topic, callback) {
		this._publisher.subscribe(topic, callback);
	}
	
	Client.prototype.unsubscribe = function(topic, callback) {
		this._publisher.unsubscribe(topic, callback);
	}

	Client.prototype.send = function(topic, data) {
		this._connection.sendUTF(JSON.stringify({
			topic: topic,
			data: data
		}));
		
		this._timeLastMessageSent = time();
	}
	
	Client.prototype._sendHeartbeatMessage = function() {
		if(time() - this._timeLastMessageSent > this._heartbeatInterval) {
			this.send("/heartbeat");
		}
	}
	
	Client.prototype._checkHeartbeat = function() {
		var timeSinceLastMessage = time() - Math.max(this._timeConnected, this._timeLastMessageReceived);
		
		if(timeSinceLastMessage > this._maxTimeBetweenMessages) {
			this.disconnect();
			this.Disconnected.fire();
		}
	}
	
	Client.prototype.disconnect = function() {
		this._connection.close();
	}
	
	Client.prototype._setupConnection = function() {
		this._connection.on("message", (function(message) {
			if(message.type === "utf8") {
				var data = JSON.parse(message.utf8Data);
				
				this._publisher.publish(data.topic, data.data);
				this._timeLastMessageReceived = time();
			}
		}).bind(this));
		
		this._connection.on("close", (function() {
			clearInterval(this._heartbeatLoop);
			this.Disconnected.fire();
		}).bind(this));
	}
	
	Client.prototype.getTimeLastActive = function() {
		return Math.max(this._timeConnected, this._timeLastMessageSent, this._timeLastMessageReceived);
	}

	return Client;
});